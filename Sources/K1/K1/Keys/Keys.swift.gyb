// MARK: - Generated file, do NOT edit
// any edits of this file WILL be overwritten and thus discarded
// see section `gyb` in `README` for details.

import Foundation

%{
	LIST_KEY_FOR_FEATURE_WITH_DOCS = [
		{ "feature": "Schnorr", "docSK": "private key for schnoriri", "docPK": "pub key for schnooorrriiii" },
		{ "feature": "KeyAgreement", "docSK": "private key for keyagremt", "docPK": "pub key for ec dh adhd" },
		{ "feature": "ECDSA.NonRecoverable", "docSK": "sign key nonrec", "docPK": "pub key verif key nonrec" },
		{ "feature": "ECDSA.Recoverable", "docSK": "sign key reccco", "docPK": "pub key verif key recoo" },
	]
}%
% for KEY_FOR_FEATURE_WITH_DOCS in LIST_KEY_FOR_FEATURE_WITH_DOCS:
%{
	FEATURE = KEY_FOR_FEATURE_WITH_DOCS["feature"]
	DocPrivateKey = KEY_FOR_FEATURE_WITH_DOCS["docSK"]
	DocPublicKey = KEY_FOR_FEATURE_WITH_DOCS["docPK"]
}%
// MARK: - ${FEATURE}
extension K1.${FEATURE} {
	// MARK: PrivateKey
	/// ${DocPrivateKey}
	public struct PrivateKey: Sendable, Hashable, K1PrivateKeyProtocol {
		public init() {
			self.init(impl: .init())
		}

		public init(rawRepresentation: some ContiguousBytes) throws {
			try self.init(impl: .init(rawRepresentation: rawRepresentation))
		}

		public init(x963Representation: some ContiguousBytes) throws {
			try self.init(impl: .init(x963Representation: x963Representation))
		}

		public init(derRepresentation: some RandomAccessCollection<UInt8>) throws {
			try self.init(impl: .init(derRepresentation: derRepresentation))
		}

		public init(pemRepresentation: String) throws {
			try self.init(impl: .init(pemRepresentation: pemRepresentation))
		}

		public var rawRepresentation: Data {
			impl.rawRepresentation
		}

		public var x963Representation: Data {
			impl.x963Representation
		}

		public var derRepresentation: Data {
			impl.derRepresentation
		}

		public var pemRepresentation: String {
			impl.pemRepresentation
		}

		typealias Impl = K1._PrivateKeyImplementation
		internal let impl: Impl
		internal let publicKeyImpl: K1._PublicKeyImplementation

		public typealias PublicKey = K1.${FEATURE}.PublicKey
		public var publicKey: PublicKey {
			try! .init(rawRepresentation: publicKeyImpl.rawRepresentation)
		}

		init(impl: Impl) {
			self.impl = impl
			self.publicKeyImpl = impl.publicKey
		}
	}

	// MARK: PublicKey
	/// ${DocPublicKey}
	public struct PublicKey: Sendable, Hashable, K1PublicKeyProtocol {
		public init(rawRepresentation: some ContiguousBytes) throws {
			try self.init(impl: .init(rawRepresentation: rawRepresentation))
		}

		public init(compressedRepresentation: some ContiguousBytes) throws {
			try self.init(impl: .init(compressedRepresentation: compressedRepresentation))
		}

		public init(x963Representation: some ContiguousBytes) throws {
			try self.init(impl: .init(x963Representation: x963Representation))
		}

		public init(derRepresentation: some RandomAccessCollection<UInt8>) throws {
			try self.init(impl: .init(derRepresentation: derRepresentation))
		}

		public init(pemRepresentation: String) throws {
			try self.init(impl: .init(pemRepresentation: pemRepresentation))
		}

		public var rawRepresentation: Data {
			impl.rawRepresentation
		}

		public var x963Representation: Data {
			impl.x963Representation
		}

		public var derRepresentation: Data {
			impl.derRepresentation
		}

		public var compressedRepresentation: Data {
			impl.compressedRepresentation
		}

		public var pemRepresentation: String {
			impl.pemRepresentation
		}

		typealias Impl = K1._PublicKeyImplementation
		internal let impl: Impl
		internal init(impl: Impl) {
			self.impl = impl
		}
	}
}

	% end
	% end
