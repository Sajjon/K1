// MARK: - Generated file, do NOT edit
// any edits of this file WILL be overwritten and thus discarded
// see section `gyb` in `README` for details.

import Foundation
import struct CryptoKit.SHA256
import protocol CryptoKit.Digest

// MARK: - K1.ECDSA
extension K1 {
	/// A mechanism used to create or verify a cryptographic signature using the `secp256k1` elliptic curve digital signature algorithm (ECDSA).
	public enum ECDSA {}
}

// MARK: - K1.ECDSA.ValidationOptions
extension K1.ECDSA {
	public struct ValidationOptions {
		public let malleabilityStrictness: MalleabilityStrictness

		public init(malleabilityStrictness: MalleabilityStrictness) {
			self.malleabilityStrictness = malleabilityStrictness
		}
	}
}

extension K1.ECDSA.ValidationOptions {
	public static let `default`: Self = .init(
		malleabilityStrictness: .rejected
	)

	/// Whether or not to consider malleable signatures valid.
	///
	/// [more]: https://github.com/bitcoin-core/secp256k1/blob/2e5e4b67dfb67950563c5f0ab2a62e25eb1f35c5/include/secp256k1.h#L510-L550
	public enum MalleabilityStrictness {
		/// Considers all malleable signatures **invalid**.
		case rejected

		/// Accepts malleable signatures valid.
		case accepted
	}
}

// MARK: - K1.ECDSA.SigningOptions
extension K1.ECDSA {
	public struct SigningOptions: Sendable, Hashable {
		public let nonceFunction: NonceFunction

		public init(nonceFunction: NonceFunction) {
			self.nonceFunction = nonceFunction
		}
	}
}

extension K1.ECDSA.SigningOptions {
	public static let `default`: Self = .init(nonceFunction: .deterministic())

	public enum NonceFunction: Sendable, Hashable {
		case random

		/// RFC6979
		case deterministic(arbitraryData: RFC6979ArbitraryData? = nil)
	}
}

// MARK: - K1.ECDSA.SigningOptions.NonceFunction.RFC6979ArbitraryData
extension K1.ECDSA.SigningOptions.NonceFunction {
	public struct RFC6979ArbitraryData: Sendable, Hashable {
		public let arbitraryData: [UInt8]
		public init(arbitraryData: [UInt8]) throws {
			guard arbitraryData.count == Curve.Field.byteCount else {
				throw K1.Error.incorrectByteCountOfArbitraryDataForNonceFunction
			}
			self.arbitraryData = arbitraryData
		}
	}
}

%{
	VARIANTS_OF_FEATURE = [
		{
			"scheme": "ECDSA",
			"feature": "ECDSA.NonRecoverable",
			"variant": "an Elliptic Curve Digital Signature Algorithm (ECDSA) non recoverable",
			"docSignParameterOptions": "Whether or not to consider malleable signatures valid",
			"docValidationParameterOptions": "\n///   - options: Whether or not to consider malleable signatures valid.",
			"validationOptionsArg": ",\noptions: K1.ECDSA.ValidationOptions = .default",
			"validationOptionsFwd": ",\noptions: options",
		},
		{
			"scheme": "ECDSA",
			"feature": "ECDSA.Recoverable",
			"variant": "an Elliptic Curve Digital Signature Algorithm (ECDSA) recoverable",
			"docSignParameterOptions": "Whether or not to consider malleable signatures valid",
			"docValidationParameterOptions": "\n///   - options: Whether or not to consider malleable signatures valid.",
			"validationOptionsArg": ",\noptions: K1.ECDSA.ValidationOptions = .default",
			"validationOptionsFwd": ",\noptions: options",

		},
		{
			"scheme": "Schnorr",
			"feature": "Schnorr",
			"variant": "Schnorr",
			"docSignParameterOptions": "Optional auxiliary random data to use when forming nonce for the signature.",
			"docValidationParameterOptions": "",
			"validationOptionsArg": "",
			"validationOptionsFwd": "",
		}
	]
}%
% for VARIANT_OF_FEATURE in VARIANTS_OF_FEATURE:
%{
	FEATURE = VARIANT_OF_FEATURE["feature"]
	SCHEME = VARIANT_OF_FEATURE["scheme"]
	VARIANT = VARIANT_OF_FEATURE["variant"]
	DOC_SIGN_PARAM_OPTIONS = VARIANT_OF_FEATURE["docSignParameterOptions"]
	DOC_VALIDATION_PARAM_OPTIONS = VARIANT_OF_FEATURE["docValidationParameterOptions"]
	VALIDATION_OPTIONS_ARG = VARIANT_OF_FEATURE["validationOptionsArg"]
	VALIDATION_OPTIONS_FWD = VARIANT_OF_FEATURE["validationOptionsFwd"]
}%
// MARK: Sign + ${FEATURE}
extension K1.${FEATURE}.PrivateKey {
	/// Generates ${VARIANT} signature of _hashed_ data you provide over the `secp256k1` elliptic curve.
	/// - Parameters:
	///   - hashed: The _hashed_ data to sign.
	///   - options: ${DOC_SIGN_PARAM_OPTIONS}.
	/// - Returns: The ${VARIANT} signature corresponding to the data. The signing algorithm uses deterministic or random nonces, dependent on `options`, thus either deterministically producing the same signature or the same data and key, or different on every call.
	public func signature(
		for hashed: some DataProtocol,
		options: K1.${SCHEME}.SigningOptions = .default
	) throws -> K1.${FEATURE}.Signature {
		try K1.${FEATURE}.Signature(
			wrapped: FFI.${FEATURE}.sign(
				hashedMessage: [UInt8](hashed),
				privateKey: impl.wrapped,
				options: options
			)
		)
	}

	/// Generates ${VARIANT} signature of the digest you provide over the `secp256k1` elliptic curve.
	/// - Parameters:
	///   - digest: The digest of the data to sign.
	///   - options: ${DOC_SIGN_PARAM_OPTIONS}.
	/// - Returns: The ${VARIANT} signature corresponding to the data. The signing algorithm uses deterministic or random nonces, dependent on `options`, thus either deterministically producing the same signature or the same data and key, or different on every call.
	public func signature(
		for digest: some Digest,
		options: K1.${SCHEME}.SigningOptions = .default
	) throws -> K1.${FEATURE}.Signature {
		try signature(
			for: Data(digest),
			options: options
		)
	}

	/// Generates ${VARIANT} signature of the given data over the `secp256k1` elliptic curve, using SHA-256 as a hash function.
	/// - Parameters:
	///   - unhashed: The data hash and then to sign.
	///   - options: ${DOC_SIGN_PARAM_OPTIONS}.
	/// - Returns: The ${VARIANT} signature corresponding to the data. The signing algorithm uses deterministic or random nonces, dependent on `options`, thus either deterministically producing the same signature or the same data and key, or different on every call.
	public func signature(
		forUnhashed unhashed: some DataProtocol,
		options: K1.${SCHEME}.SigningOptions = .default
	) throws -> K1.${FEATURE}.Signature {
		try signature(
			for: SHA256.hash(data: unhashed),
			options: options
		)
	}
}

// MARK: Verify + ${FEATURE}
extension K1.${FEATURE}.PublicKey {
	/// Verifies an elliptic curve digital signature algorithm (ECDSA) ${VARIANT} signature on some _hash_ over the `secp256k1` elliptic curve.
	/// - Parameters:
	///   - signature: The ${VARIANT} signature to check against the _hashed_ data.
	///   - hashed: The _hashed_ data covered by the signature.${DOC_VALIDATION_PARAM_OPTIONS}
	/// - Returns: A Boolean value that’s true if the ${VARIANT} signature is valid for the given _hashed_ data.
	public func isValidSignature(
		_ signature: K1.${FEATURE}.Signature,
		hashed: some DataProtocol${VALIDATION_OPTIONS_ARG}
	) -> Bool {
		do {
			return try FFI.${FEATURE}.isValid(
				signature: signature.wrapped,
				publicKey: self.impl.wrapped,
				message: [UInt8](hashed)${VALIDATION_OPTIONS_FWD}
			)
		} catch {
			return false
		}
	}

	/// Verifies an elliptic curve digital signature algorithm (ECDSA) ${VARIANT} signature on a digest over the `secp256k1` elliptic curve.
	/// - Parameters:
	///   - signature: The ${VARIANT} signature to check against the given digest.
	///   - digest: The digest covered by the signature.${DOC_VALIDATION_PARAM_OPTIONS}
	/// - Returns: A Boolean value that’s true if the ${VARIANT} signature is valid for the given digest.
	public func isValidSignature(
		_ signature: K1.${FEATURE}.Signature,
		digest: some Digest${VALIDATION_OPTIONS_ARG}
	) -> Bool {
		isValidSignature(
			signature,
			hashed: Data(digest)${VALIDATION_OPTIONS_FWD}
		)
	}

	/// Verifies an elliptic curve digital signature algorithm (ECDSA) ${VARIANT} signature on a block of data over the `secp256k1` elliptic curve.
	///
	/// The function computes an SHA-256 hash from the data before verifying the signature. If you separately hash the data to be signed, use `isValidSignature(_:digest:input)` with the created digest. Or if you have access to a digest just as `some DataProtocol`, use
	/// `isValidSignature(_:hashed:input)`.
	///
	/// - Parameters:
	///   - signature: The ${VARIANT} signature to check against the given digest.
	///   - unhashed: The block of data covered by the signature.${DOC_VALIDATION_PARAM_OPTIONS}
	/// - Returns: A Boolean value that’s true if the ${VARIANT} signature is valid for the given block of data.
	public func isValidSignature(
		_ signature: K1.${FEATURE}.Signature,
		unhashed: some DataProtocol${VALIDATION_OPTIONS_ARG}
	) -> Bool {
		isValidSignature(
			signature,
			digest: SHA256.hash(data: unhashed)${VALIDATION_OPTIONS_FWD}
		)
	}
}

% end
% end
